# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

charset_0 = list(chain(*multirange_diff(printable_unicode_ranges, [(38, 39),(60, 61)])))
charset_1 = list(chain(*multirange_diff(printable_unicode_ranges, [(34, 35),(60, 61)])))
charset_2 = list(chain(*multirange_diff(printable_unicode_ranges, [(39, 40),(60, 61)])))
charset_3 = list(chain(range(32, 33), range(9, 10), range(13, 14), range(10, 11)))
charset_4 = list(chain(range(97, 103), range(65, 71), range(48, 58)))
charset_5 = list(chain(range(48, 58)))
charset_6 = list(chain(range(58, 59), range(97, 123), range(65, 91)))


class XMLUnlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(XMLUnlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def COMMENT(self):
        current = self.create_node(UnlexerRule(name='COMMENT'))
        current += self.create_node(UnlexerRule(src='<!--'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src='-->'))
        return current
    COMMENT.min_depth = 0

    @depthcontrol
    def CDATA(self):
        current = self.create_node(UnlexerRule(name='CDATA'))
        current += self.create_node(UnlexerRule(src='<![CDATA['))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src=']]>'))
        return current
    CDATA.min_depth = 0

    @depthcontrol
    def DTD(self):
        current = self.create_node(UnlexerRule(name='DTD'))
        current += self.create_node(UnlexerRule(src='<!'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src='>'))
        return current
    DTD.min_depth = 0

    @depthcontrol
    def EntityRef(self):
        current = self.create_node(UnlexerRule(name='EntityRef'))
        current += self.create_node(UnlexerRule(src='&'))
        current += self.unlexer.Name()
        current += self.create_node(UnlexerRule(src=';'))
        return current
    EntityRef.min_depth = 2

    @depthcontrol
    def CharRef(self):
        current = self.create_node(UnlexerRule(name='CharRef'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_11', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_11', choice)] = self.unlexer.weights.get(('alt_11', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='&#'))
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.unlexer.DIGIT()

            current += self.create_node(UnlexerRule(src=';'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='&#x'))
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.unlexer.HEXDIGIT()

            current += self.create_node(UnlexerRule(src=';'))
        return current
    CharRef.min_depth = 1

    @depthcontrol
    def SEA_WS(self):
        current = self.create_node(UnlexerRule(name='SEA_WS'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_18', i), 1) for i, w in enumerate([1, 1, 1])])
                self.unlexer.weights[('alt_18', choice)] = self.unlexer.weights.get(('alt_18', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.create_node(UnlexerRule(src=' '))
                elif choice == 1:
                    current += self.create_node(UnlexerRule(src='\t'))
                elif choice == 2:
                    if self.unlexer.max_depth >= 0:
                        for _ in self.zero_or_one():
                            current += self.create_node(UnlexerRule(src='\r'))

                    current += self.create_node(UnlexerRule(src='\n'))

        return current
    SEA_WS.min_depth = 0

    @depthcontrol
    def OPEN(self):
        current = self.create_node(UnlexerRule(name='OPEN'))
        current += self.create_node(UnlexerRule(src='<'))
        return current
    OPEN.min_depth = 0

    @depthcontrol
    def XMLDeclOpen(self):
        current = self.create_node(UnlexerRule(name='XMLDeclOpen'))
        current += self.create_node(UnlexerRule(src='<?xml'))
        current += self.unlexer.S()
        return current
    XMLDeclOpen.min_depth = 1

    @depthcontrol
    def SPECIAL_OPEN(self):
        current = self.create_node(UnlexerRule(name='SPECIAL_OPEN'))
        current += self.create_node(UnlexerRule(src='<?'))
        current += self.unlexer.Name()
        return current
    SPECIAL_OPEN.min_depth = 2

    @depthcontrol
    def TEXT(self):
        current = self.create_node(UnlexerRule(name='TEXT'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += UnlexerRule(src=self.char_from_list(charset_0))

        return current
    TEXT.min_depth = 0

    @depthcontrol
    def CLOSE(self):
        current = self.create_node(UnlexerRule(name='CLOSE'))
        current += self.create_node(UnlexerRule(src='>'))
        return current
    CLOSE.min_depth = 0

    @depthcontrol
    def SPECIAL_CLOSE(self):
        current = self.create_node(UnlexerRule(name='SPECIAL_CLOSE'))
        current += self.create_node(UnlexerRule(src='?>'))
        return current
    SPECIAL_CLOSE.min_depth = 0

    @depthcontrol
    def SLASH_CLOSE(self):
        current = self.create_node(UnlexerRule(name='SLASH_CLOSE'))
        current += self.create_node(UnlexerRule(src='/>'))
        return current
    SLASH_CLOSE.min_depth = 0

    @depthcontrol
    def SLASH(self):
        current = self.create_node(UnlexerRule(name='SLASH'))
        current += self.create_node(UnlexerRule(src='/'))
        return current
    SLASH.min_depth = 0

    @depthcontrol
    def EQUALS(self):
        current = self.create_node(UnlexerRule(name='EQUALS'))
        current += self.create_node(UnlexerRule(src='='))
        return current
    EQUALS.min_depth = 0

    @depthcontrol
    def STRING(self):
        current = self.create_node(UnlexerRule(name='STRING'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_35', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_35', choice)] = self.unlexer.weights.get(('alt_35', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='"'))
            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_more():
                    current += UnlexerRule(src=self.char_from_list(charset_1))

            current += self.create_node(UnlexerRule(src='"'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\''))
            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_more():
                    current += UnlexerRule(src=self.char_from_list(charset_2))

            current += self.create_node(UnlexerRule(src='\''))
        return current
    STRING.min_depth = 0

    @depthcontrol
    def Name(self):
        current = self.create_node(UnlexerRule(name='Name'))
        current += self.unlexer.NameStartChar()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NameChar()

        return current
    Name.min_depth = 1

    @depthcontrol
    def S(self):
        current = self.create_node(UnlexerRule(name='S'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_3)))
        return current
    S.min_depth = 0

    @depthcontrol
    def HEXDIGIT(self):
        current = self.create_node(UnlexerRule(name='HEXDIGIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_4)))
        return current
    HEXDIGIT.min_depth = 0

    @depthcontrol
    def DIGIT(self):
        current = self.create_node(UnlexerRule(name='DIGIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_5)))
        return current
    DIGIT.min_depth = 0

    @depthcontrol
    def NameChar(self):
        current = self.create_node(UnlexerRule(name='NameChar'))
        choice = self.choice([0 if [1, 0, 0, 0, 1, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_45', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_45', choice)] = self.unlexer.weights.get(('alt_45', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NameStartChar()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='-'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='_'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='.'))
        elif choice == 4:
            current += self.unlexer.DIGIT()
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='\u00B7'))
        elif choice == 6:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(768, 879))))
        elif choice == 7:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(8255, 8256))))
        return current
    NameChar.min_depth = 0

    @depthcontrol
    def NameStartChar(self):
        current = self.create_node(UnlexerRule(name='NameStartChar'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_58', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_58', choice)] = self.unlexer.weights.get(('alt_58', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src=self.char_from_list(charset_6)))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(8304, 8591))))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(11264, 12271))))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(12289, 55295))))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(63744, 64975))))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(65008, 65533))))
        return current
    NameStartChar.min_depth = 0

    @depthcontrol
    def PI(self):
        current = self.create_node(UnlexerRule(name='PI'))
        current += self.create_node(UnlexerRule(src='?>'))
        return current
    PI.min_depth = 0

    @depthcontrol
    def IGNORE(self):
        current = self.create_node(UnlexerRule(name='IGNORE'))
        current += UnlexerRule(src=self.any_char())
        return current
    IGNORE.min_depth = 0

